####
# Marriage and the Medici clan
####
## load the igraph package
library(igraph)
medici = as.matrix(read.table("../data/medici.txt"))
setwd("~/Dropbox/SalemCenter/classes/DataScienceEconPolicy/Spring2023/Data-Science-for-Economics-and-Policy/code")
medici = as.matrix(read.table("../data/medici.txt"))
## create the graph object
marriage = graph.edgelist(medici, directed=FALSE)
V(marriage)$color = "orange"
V(marriage)["Medici"]$color = "lightblue"
V(marriage)$frame.color = 0
V(marriage)$label.color = "black"
## plot it
plot(marriage, edge.curved=FALSE)
plot(marriage, edge.curved=FALSE)
sort(degree(marriage))
library(tidyverse)
library(arules)  # has a big ecosystem of packages built around it
library(arulesViz)
# Association rule mining
# Read in playlists from users
# This is in "long" format -- every row is a single artist-listener pair
playlists_raw = read.csv("../data/playlists.csv")
str(playlists_raw)
summary(playlists_raw)
# Turn user into a factor
playlists_raw$user = factor(playlists_raw$user)
# apriori algorithm expects a list of baskets in a special format
# In this case, one "basket" of songs per user
# First split data into a list of artists for each user
playlists = split(x=playlists_raw$artist, f=playlists_raw$user)
## Remove duplicates ("de-dupe")
playlists = lapply(playlists, unique)
## Cast this variable as a special arules "transactions" class.
playtrans = as(playlists, "transactions")
summary(playtrans)
# Now run the 'apriori' algorithm
# Look at rules with support > .005 & confidence >.1 & length (# artists) <= 5
musicrules = apriori(playtrans,
parameter=list(support=.005, confidence=.1, maxlen=5))
# Look at the output... so many rules!
inspect(musicrules)
## Choose a subset
inspect(subset(musicrules, subset=lift > 5))
inspect(subset(musicrules, subset=confidence > 0.6))
inspect(subset(musicrules, subset=lift > 10 & confidence > 0.5))
# plot all the rules in (support, confidence) space
# notice that high lift rules tend to have low support
plot(musicrules)
# can swap the axes and color scales
plot(musicrules, measure = c("support", "lift"), shading = "confidence")
# "two key" plot: coloring is by size (order) of item set
plot(musicrules, method='two-key plot')
# can now look at subsets driven by the plot
inspect(subset(musicrules, support > 0.035))
inspect(subset(musicrules, confidence > 0.7))
# graph-based visualization
sub1 = subset(musicrules, subset=confidence > 0.01 & support > 0.005)
summary(sub1)
plot(sub1, method='graph')
# graph-based visualization
sub1 = subset(musicrules, subset=confidence > 0.1 & support > 0.005)
summary(sub1)
plot(sub1, method='graph')
plot(head(sub1, 100, by='lift'), method='graph')
dev.off()
####
# Marriage and the Medici clan
####
## load the igraph package
library(igraph)
medici = as.matrix(read.table("../data/medici.txt"))
## create the graph object
marriage = graph.edgelist(medici, directed=FALSE)
medici
## set some color atributes (V() gives back the 'vertices' = nodes)
V(marriage)$color = "orange"
V(marriage)["Medici"]$color = "lightblue"
V(marriage)$frame.color = 0
V(marriage)$label.color = "black"
## plot it
plot(marriage, edge.curved=FALSE)
## print the degree for each family
sort(degree(marriage))
## calculate and color a couple shortest paths
PtoA = get.shortest.paths(marriage, from="Peruzzi", to="Acciaiuoli")
PtoA
allPtoA = all_shortest_paths(marriage, from="Peruzzi", to="Acciaiuoli")
allPtoA
PtoA$vpath[[1]]
GtoS = get.shortest.paths(marriage, from="Ginori", to="Strozzi")
GtoS$vpath[[1]]
E(marriage)$width = 2
E(marriage)$color = "grey"
E(marriage, path=PtoA$vpath[[1]])$color = "purple"
E(marriage, path=GtoS$vpath[[1]])$color = "darkgreen"
plot(marriage)
## print the betweenness for each family
sort(round(betweenness(marriage),1))
library(tidyverse)
library(arules)  # has a big ecosystem of packages built around it
library(arulesViz)
# Association rule mining
# Read in playlists from users
# This is in "long" format -- every row is a single artist-listener pair
playlists_raw = read.csv("../data/playlists.csv")
str(playlists_raw)
summary(playlists_raw)
dim(playlists_raw)
head(playlists_raw)
# Turn user into a factor
playlists_raw$user = factor(playlists_raw$user)
playlists = split(x=playlists_raw$artist, f=playlists_raw$user)
paylists
playlists
playlists[[1]]
playlists[[300]]
## Remove duplicates ("de-dupe")
playlists = lapply(playlists, unique)
length(playlists)
playtrans = as(playlists, "transactions")
summary(playtrans)
musicrules = apriori(playtrans,
parameter=list(support=.005, confidence=.1, maxlen=5))
# Look at the output... so many rules!
inspect(musicrules)
# Look at the output... so many rules!
inspect(musicrules)
inspect(subset(musicrules, subset=lift > 5))
plot(musicrules)
# can swap the axes and color scales
plot(musicrules, measure = c("support", "lift"), shading = "confidence")
# "two key" plot: coloring is by size (order) of item set
plot(musicrules, method='two-key plot')
sub1 = subset(musicrules, subset=confidence > 0.1 & support > 0.005)
summary(sub1)
sub1 = subset(musicrules, subset=confidence > 0.5 & support > 0.005)
summary(sub1)
plot(sub1, method='graph')
library(arules)  # has a big ecosystem of packages built around it
library(arules)  # has a big ecosystem of packages built around it
library(arulesViz)
remove.packages("arules")
install.packages("arules")
install.packages("arules")
library(arules)
