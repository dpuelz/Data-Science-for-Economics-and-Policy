#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
#### end block
pc_Z = prcomp(Z, rank=3)
pc_Z$rotation
v_try #compare with our "guess and check" PC
pc_Z$rotation
v_try #compare with our "guess and check" PC
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
#### begin block
v_try = rnorm(2)
v_try = v_try/sqrt(sum(v_try^2))  # normalize to unit length
par(mfrow=c(1,2))
plot(Z, pch=19, col=rgb(0.3,0.3,0.3,0.3),
xlim=c(-2.5,2.5), ylim=c(-2.5,2.5))
slope = v_try[2]/v_try[1]
abline(0, slope)  # plot the subspace as a line
# Project the points onto that subspace
alpha = Z %*% v_try  # inner product of each row with v_try
z_hat = alpha %*% v_try  # locations in R^2
points(z_hat, col='blue', pch=4)
segments(0, 0, v_try[1], v_try[2], col='red', lwd=4)
# the number at the top is the variance of the projected points
hist(alpha, 25, xlim=c(-3,3), main=round(var(alpha), 2))
# the principal components themselves are in the "rotation" component
# synonym: loadings
pc_Z$rotation
v_try #compare with our "guess and check" PC
summary(pc_Z)
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
### data on tv shows from NBC market research
## show details; ratings and engagement
# https://digiday.com/marketing/what-is-a-grp-gross-ratings-point/
shows = read.csv("../data/nbc_showdetails.csv", row.names=1)
heaD(shows)
head(shows)
# predicted engagement versus gross ratings points
ggplot(shows) +
geom_point(aes(x=PE, y=GRP, color=Genre))
survey = read.csv("../data/nbc_pilotsurvey.csv")
head(survey)
dim(survey)
# there are lots of survey respondents
# let's calculate an average response for each show, for each question,
# across all respondents
pilot_results = survey %>%
group_by(Show) %>%
select(-Viewer) %>%
summarize_all(mean) %>%
column_to_rownames(var="Show")
# now we have a tidy matrix of shows by questions
# each entry is an average survey response
head(pilot_results)
dim(pilot_results)
# a few quick plots
ggplot(rownames_to_column(pilot_results, "Show")) +
geom_col(aes(x=reorder(Show, -Q2_Relatable), y = Q2_Relatable)) +
coord_flip()
ggplot(rownames_to_column(pilot_results, "Show")) +
geom_col(aes(x=reorder(Show, -Q2_Confusing), y = Q2_Confusing)) +
coord_flip()
# a look at the correlation matrix
cor(pilot_results)
# a look at the correlation matrix
cor(pilot_results)
# a quick heatmap visualization
ggcorrplot::ggcorrplot(cor(pilot_results))
# looks a mess -- reorder the variables by hierarchical clustering
ggcorrplot::ggcorrplot(cor(pilot_results), hc.order = TRUE)
PCApilot = prcomp(pilot_results, scale=TRUE)
plot(PCApilot)
plot(PCApilot)
dev.off()
## variance plot
plot(PCApilot)
summary(PCApilot)
round(PCApilot$rotation[,1:3],2)
loadings_summary = PCApilot$rotation %>%
as.data.frame() %>%
rownames_to_column('Question')
loadings_summary %>%
select(Question, PC1) %>%
arrange(desc(PC1))
# this just seems to load negatively on most things
# honestly not sure!
loadings_summary %>%
select(Question, PC2) %>%
arrange(desc(PC2))
# this looks clearly like a drama vs comedy axis
loadings_summary %>%
select(Question, PC3) %>%
arrange(desc(PC3))
shows = merge(shows, PCApilot$x[,1:3], by="row.names")
shows = rename(shows, Show = Row.names)
ggplot(shows) +
geom_col(aes(x=reorder(Show, PC1), y=PC1)) +
coord_flip()
loadings_summary %>%
select(Question, PC2) %>%
arrange(desc(PC2))
ggplot(shows) +
geom_col(aes(x=reorder(Show, PC3), y=PC3)) +
coord_flip()
lm1 = lm(PE ~ PC1 + PC2 + PC3, data=shows)
summary(lm1)
# gross ratings points
lm2 = lm(GRP ~ PC1 + PC2 + PC3, data=shows)
summary(lm2)
plot(PE ~ fitted(lm1), data=shows)
abline(0,1,lwd=2,col=2)
library(ggplot2)
countdata = read.csv("../data/congress109.csv", header=TRUE, row.names=1)
memberdata = read.csv("../data/congress109members.csv", header=TRUE, row.names=1)
Z = countdata/rowSums(countdata)
head(countdata)
dim(countdata)
countdata[1,]
head(memberdata)
Z = countdata/rowSums(countdata)
hist(rowSums(countdata))
hist(rowSums(countdata))
summary(rowSums(countdata))
# PCA
pc2 = prcomp(Z, scale=TRUE, rank=2)
loadings = pc2$rotation
scores = pc2$x
qplot(scores[,1], scores[,2], color=memberdata$party, xlab='Component 1', ylab='Component 2')
qplot(scores[,1], scores[,2], color=memberdata$party, xlab='Component 1', ylab='Component 2') + scale_color_manual(values=c("blue", "grey", "red"))
o1 = order(loadings[,1], decreasing=TRUE)
colnames(Z)[head(o1,25)]
colnames(Z)[tail(o1,25)]
o2 = order(loadings[,2], decreasing=TRUE)
colnames(Z)[head(o2,25)]
colnames(Z)[tail(o2,25)]
plot(pc2)
summary(pc2)
library(tidyverse)
library(ggplot2)
library(usmap)
library(lubridate)
library(randomForest)
library(splines)
library(pdp)
# Note: before loading the data,
# you'll first need to unzip the ercot folder
# (too big for GitHub if not compressed)
# Power grid load every hour for 6 1/2 years
# throughout the 8 ERCOT regions of Texas
# units of grid load are megawatts.
# This represents peak instantaneous demand for power in that hour.
# source: scraped from the ERCOT website
load_data = read.csv("../data/load_data.csv")
head(load_data)
temperature_impute = read.csv("../data/temperature_impute.csv", row.names=1)
setwd("~/Dropbox/SalemCenter/classes/DataScienceEconPolicy/Spring2023/Data-Science-for-Economics-and-Policy/code")
temperature_impute = read.csv("../data/temperature_impute.csv", row.names=1)
# Now weather data at hundreds of weather stations
# throughout Texas and the surrounding region
# Note: I've imputed a handful of sporadic missing values
# Source: National Weather Service
temperature_impute = read.csv("../data/ercot/temperature_impute.csv", row.names=1)
station_data = read.csv("../data/ercot/station_data.csv", row.names=1)
head(temperature_impute)
head(station_data)
# some dates have completely missing weather data
# Keep the load data for dates when we have weather data
mysub = which(ymd_hms(load_data$Time) %in% ymd_hms(rownames(temperature_impute)))
load_data = load_data[mysub,]
# De-duplicate the weather data by merging on first match of date in the load data
temp_ind = match(ymd_hms(load_data$Time), ymd_hms(rownames(temperature_impute)))
temperature_impute = temperature_impute[temp_ind,]
# Take the time stamps from the load data
time_stamp = ymd_hms(load_data$Time)
# Verify that the time stamps match row by row across the two data frames
all(time_stamp ==  ymd_hms(rownames(temperature_impute)))
# a lot of these station names are in Mexico or the Gulf
# and we don't have temperature data on them
station_data = subset(station_data, state != 'MX')
station_map = station_data %>%
select(lon, lat) %>%
usmap_transform
station_map = station_data %>%
select(lon, lat) %>%
usmap_transform
head(station_map)
# now merge these coordinates station name
station_data = station_data %>% rownames_to_column('station')
station_data = merge(station_data, station_map, by=c('lat', 'lon'))
head(station_data)
# plot the coordinates of the weather stations
plot_usmap(include = c("TX", "LA", "OK", "NM", "AR")) +
geom_point(data=station_data, aes(x=lon.1, y=lat.1))
colnames(station_data)
plot_usmap(include = c("TX", "LA", "OK", "NM", "AR")) +
geom_point(data=station_data, aes(x=lon, y=lat))
# Take the time stamps from the load data
time_stamp = ymd_hms(load_data$Time)
# Verify that the time stamps match row by row across the two data frames
all(time_stamp ==  ymd_hms(rownames(temperature_impute)))
# a lot of these station names are in Mexico or the Gulf
# and we don't have temperature data on them
station_data = subset(station_data, state != 'MX')
# Make a map.
# First, project project the lon, lat coordinates
# to the same coordinate system used by usmap
station_map = station_data %>%
select(lon, lat) %>%
usmap_transform
head(station_map)
# now merge these coordinates station name
station_data = station_data %>% rownames_to_column('station')
# plot the coordinates of the weather stations
plot_usmap(include = c("TX", "LA", "OK", "NM", "AR")) +
geom_point(data=station_data, aes(x=lon, y=lat))
station_data
# plot the coordinates of the weather stations
plot_usmap(include = c("TX", "LA", "OK", "NM", "AR")) +
geom_point(data=station_data, aes(x=x, y=y))
dim(temperature_impute)
pc_weather = prcomp(temperature_impute, rank=5, scale=TRUE)
head(pc_weather$rotation)
summary(pc_weather)
loadings = pc_weather$rotation %>%
as.data.frame %>%
rownames_to_column('station')
station_data = merge(station_data, loadings, by = 'station')
head(station_data)
# set up the map and the color scale
p0 = plot_usmap(include = c("TX", "LA", "OK", "NM", "AR")) +
scale_color_gradient(low = 'blue', high='red')
p0 + geom_point(data=station_data, aes(x=lon.1, y=lat.1, color=PC1))
p0 + geom_point(data=station_data, aes(x=x, y=y, color=PC1))
p0 + geom_point(data=station_data, aes(x=x, y=y, color=PC2))
p0 + geom_point(data=station_data, aes(x=x, y=y, color=PC3))
p0 + geom_point(data=station_data, aes(x=x, y=y, color=PC4))
# Second we can look at the scores, i.e. go hour by hour and ask:
# what the first summary of these 256 variables?
# What the second summary?  etc
scores = pc_weather$x
p1 = pc_weather$x %>%
as.data.frame %>%
rownames_to_column('time') %>%
mutate(time = ymd_hms(time)) %>%
ggplot
# PC score 1 over time
p1 + geom_line(aes(x=time, y=PC1))
